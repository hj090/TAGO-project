<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>After</title>
    <style>
        /* 기본 스타일 초기화 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 전체 배경 및 폰트 설정 */
        body {
            background-color: #000000;
            color: #ffffff;
            font-family: 'Noto Sans KR', Arial, sans-serif;
            padding: 60px 20px;
            min-height: 100vh;
            position: relative;
        }

        /* 🌟 되돌아가기 화살표 스타일 (좌측 상단) 🌟 */
        .back-arrow {
            position: fixed;
            top: 30px;
            left: 40px;
            color: white;
            text-decoration: none;
            font-size: 28px;
            transition: color 0.3s ease, opacity 0.5s ease;
            z-index: 10000; /* 최상단 배치 */
            opacity: 0; /* JS로 나타나기 전까지 숨김 */
        }
        .back-arrow:hover {
            color: #cccccc;
        }

        /* 🌟 페이지 전환 오버레이 스타일 (검은 원) 🌟 */
        #transition-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            background-color: black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9998;
            pointer-events: none;
            /* 기본 전환 애니메이션 설정 */
            transition: width 0.8s cubic-bezier(0.5, 0, 0.5, 1), height 0.8s cubic-bezier(0.5, 0, 0.5, 1);
        }

        /* 페이지 진입 시: 원이 축소되어 내용을 드러내는 상태 (Reveal) */
        #transition-overlay.revealing {
            width: 0; 
            height: 0;
        }

        /* 되돌아가기 클릭 시: 원이 다시 확장되어 화면을 덮는 상태 (Collapse 시작점) */
        #transition-overlay.expanded {
            width: 300vmax; 
            height: 300vmax;
        }
        /* ------------------------------------- */

        /* 컨텐츠 중앙 정렬 및 최대 너비 제한 */
        .content-wrapper {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
            /* 🌟 초기에는 오버레이가 걷힐 때까지 내용을 숨김 🌟 */
            opacity: 0; 
            transition: opacity 0.3s;
        }

        /* 제목 (h3) 스타일 */
        h3 {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 500;
            margin-bottom: 70px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            /* 멋진 그라데이션 효과 */
            background: linear-gradient(90deg, #FFFFFF 30%, #AAAAAA 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* 본문 문단 (p) 스타일 */
        p {
            font-size: 1.1rem;
            line-height: 1.8;
            margin-bottom: 35px;
            text-align: justify;
            text-justify: inter-word;
            word-break: keep-all;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 300;
        }
        
        /* 강조 텍스트 */
        .strong {
            font-weight: 500;
            color: #fff;
        }

        /* 이미지 스타일 */
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 60px auto 0 auto;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            max-height: 550px; /* 이미지 크기 조정 */
            object-fit: contain;

            /* 스크롤 애니메이션 초기 상태 */
            opacity: 0;
            transform: translateY(50px);
            transition: opacity 1s ease-out, transform 1s ease-out;
        }

        /* 스크롤 애니메이션 활성화 상태 */
        img.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 모바일 반응형 */
        @media (max-width: 768px) {
            h3 {
                font-size: 2rem;
                margin-bottom: 50px;
            }
            p {
                font-size: 1rem;
                margin-bottom: 25px;
            }
            img {
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <!-- 🌟 되돌아가기 화살표 🌟 -->
    <a href="index.html" class="back-arrow">←</a>
    
    <div class="content-wrapper">
        <h3>THE DRUM SHAMAN 작품에 대한 감상평</h3>
        <!-- 🌟 콘텐츠 복구 🌟 -->
        <p>이번 작품을 관람하며 가장 크게 느낀 점은, <span class="strong">한국의 다양한 정서와 표현 방식이 한 공연 안에서 조화롭게 드러났다는 것</span>이다. 여러 장면을 통해 각각 다른 즐거움과 감흥을 전달받을 수 있었고, 이를 통해 <span class="strong">한국의 다면적인 미적 감각</span>을 깊이 있게 체험할 수 있었다. 작품은 단순한 절제미나 고요함이 아니라, 절제와 폭발을 반복하며 살아 있는 에너지를 무대에서 유기적으로 보여주었다. 특히 초대된 관객들이 단원들의 에너지에 감화되어 음악과 소통한다는 느낌을 받았는데, 이는 공연이 관객을 적극적으로 끌어들이는 힘을 지니고 있음을 보여준다. <span class="strong">관객의 호응이 무대의 일부처럼 느껴질 만큼 단원들의 세밀한 동작과 노련함이 돋보인 점도 인상 깊었다.</span></p>
        <p>공연이 끝난 후 정보를 찾아보니, 단원들이 직접 음악감독과 예술감독을 하며 작품을 기획했다는 사실을 알게 되었다. 이로 인해 무대가 단순한 퍼포먼스가 아니라, <span class="strong">하나의 완성도 높은 종합예술</span>이었다는 점을 새삼 깨닫게 되었다. </p>
        <p>타고(TAGO) 팀의 활동을 조사하면서, 이들이 <span class="strong">그동안 세계 곳곳에서 활발히 활동하며 한국의 역동적이고 세련된 전통 문화를 알리는 데 기여해 왔다는 사실</span>을 알게 되었다. 한국의 전통 음악을 보다 널리 알릴 수 있는 무대가 앞으로 더욱 많아지길 바라는 마음이 들었다. 이 과정에서 자연스럽게 ‘내가 타고팀을 위해 할 수 있는 일은 무엇일까?’라는 고민이 이어졌다. 인공지능공학부 학생으로서 할 수 있는 일은 제한적일 것이라 생각했지만, 타고팀의 웹사이트를 살펴보며 개선하고 싶은 부분들이 눈에 띄었다. 기존 웹사이트만큼의 규모나 완성도는 아닐지라도, 사용자와의 상호작용이 뛰어난 형태로 <span class="strong">타고팀을 소개하는 웹페이지를 제작</span>해 보고자 했다. 개발 시간이 오래 소요되어 추가적인 기능을 구현하지 못한 점은 아쉬웠지만, 이번 공연을 계기로 알게 된 정보와 팀의 활동을 정리하여 웹사이트 형태로 구성해 보았다는 데 의미가 있었다. 이 작업을 통해 공연에서 받은 감동이 다시 떠올랐고, <span class="strong">앞으로도 그들의 행보에 응원을 전하고 싶다는 마음이 생겼다.</span></p>
        <img src="last.jpg" alt="타고팀무대인사" id="final-image">
        <!-- 🌟 콘텐츠 복구 끝 🌟 -->
    </div>

    <!-- 🌟 페이지 전환 오버레이 요소 🌟 -->
    <!-- 이 요소는 페이지 진입 시 확장된 상태에서 축소되어 내용을 드러내고, 나갈 때 다시 축소되어 사라지는 역할을 합니다. -->
    <div id="transition-overlay"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const finalImage = document.getElementById('final-image');
            const backArrow = document.querySelector('.back-arrow');
            const overlay = document.getElementById('transition-overlay');
            const contentWrapper = document.querySelector('.content-wrapper');
            const transitionDuration = 800; 

            // --- Utility function to force reflow/repaint ---
            const forceReflow = (element) => void element.offsetWidth;

            // --- 1. 페이지 진입 시 Reveal 애니메이션 (원 확장 상태에서 축소) ---
            if (overlay) {
                // 1.1. 초기 상태: 확장된 상태로 설정 (transition 없이)
                overlay.style.transition = 'none';
                overlay.classList.add('expanded');
                overlay.classList.remove('revealing'); // 확실하게 초기 상태 설정
                
                // 1.2. reflow 강제 (Transition: none 적용 보장)
                forceReflow(overlay); 
                
                // 1.3. 애니메이션 시작: 축소 상태로 전환하여 내용 드러내기
                setTimeout(() => {
                    // transition 속성 복구
                    overlay.style.transition = `width ${transitionDuration}ms cubic-bezier(0.5, 0, 0.5, 1), height ${transitionDuration}ms cubic-bezier(0.5, 0, 0.5, 1)`;
                    // 축소 시작 (expanded -> revealing)
                    overlay.classList.remove('expanded');
                    overlay.classList.add('revealing'); 
                    
                    // 1.4 Reveal 콘텐츠 및 화살표
                    setTimeout(() => {
                        contentWrapper.style.opacity = '1';
                        if (backArrow) backArrow.style.opacity = '1';
                    }, transitionDuration);
                }, 50); // 짧은 지연
            }

            // --- 2. 되돌아가기 버튼 클릭 시 Collapse 애니메이션 (원 축소) ---
            if (backArrow && overlay) {
                backArrow.addEventListener('click', (e) => {
                    e.preventDefault(); 
                    const targetUrl = backArrow.href;
                    
                    // A. 컨텐츠 및 화살표 숨김
                    contentWrapper.style.opacity = '0';
                    backArrow.style.opacity = '0';

                    // B. 오버레이를 화면 전체를 덮는 상태로 즉시 되돌림 (transition: none 적용)
                    overlay.style.transition = 'none'; 
                    overlay.classList.remove('revealing');
                    overlay.classList.add('expanded');
                    
                    // C. reflow 강제 (즉시 확장된 상태가 적용되도록 보장)
                    forceReflow(overlay); 

                    // D. 축소 애니메이션 시작 (애니메이션 속성 복구 및 클래스 전환)
                    setTimeout(() => {
                         // 1. transition duration을 다시 적용
                         overlay.style.transition = `width ${transitionDuration}ms cubic-bezier(0.5, 0, 0.5, 1), height ${transitionDuration}ms cubic-bezier(0.5, 0, 0.5, 1)`;

                        // 2. 축소 상태로 전환 (애니메이션 시작: expanded -> revealing)
                        overlay.classList.remove('expanded'); 
                        overlay.classList.add('revealing'); 

                        // E. 애니메이션 완료 후 페이지 이동
                        setTimeout(() => {
                            window.location.href = targetUrl;
                        }, transitionDuration); 
                    }, 50); // 짧은 지연
                });
            }

            // --- 3. 이미지 스크롤 애니메이션 (기존 로직) ---
            const observerOptions = {
                root: null,
                rootMargin: '0px',
                threshold: 0.2
            };
            
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                        observer.unobserve(entry.target); 
                    }
                });
            }, observerOptions);

            if (finalImage) {
                observer.observe(finalImage);
            }
        });
    </script>
</body>
</html>